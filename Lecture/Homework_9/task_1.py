'''
1. Даны значения величины заработной платы заемщиков банка (zp) и значения их поведенческого кредитного скоринга (ks): 
zp = [35, 45, 190, 200, 40, 70, 54, 150, 120, 110], ks = [401, 574, 874, 919, 459, 739, 653, 902, 746, 832]. 
Используя математические операции, посчитать коэффициенты линейной регрессии, приняв за X заработную плату (то есть, zp - признак), 
а за y - значения скорингового балла (то есть, ks - целевая переменная). Произвести расчет как с использованием intercept, так и без.

2. Посчитать коэффициент линейной регрессии при заработной плате (zp), используя градиентный спуск (без intercept).

3. (Дополнительно). Произвести вычисления как в пункте 2, но с вычислением intercept. 
Учесть, что изменение коэффициентов должно производиться на каждом шаге одновременно 
(то есть изменение одного коэффициента не должно влиять на изменение другого во время одной итерации).
'''
import numpy as np

zp = np.array([35, 45, 190, 200, 40, 70, 54, 150, 120, 110])
ks = np.array([401, 574, 874, 919, 459, 739, 653, 902, 746, 832])
n = 10

b1 = (n*np.sum(zp*ks) - np.sum(zp)*np.sum(ks)) / \
    (n*np.sum(zp**2) - np.sum(zp)**2)

#по второму способу
b1_1 = (np.mean(zp*ks) - np.mean(zp)*np.mean(ks)) / \
    (np.mean(zp**2) - np.mean(zp)**2)

b0 = np.mean(ks) - b1*np.mean(zp)


ks_pred = b0 + b1 * zp
print(b1, b1_1, b0, ks_pred)
'''
2.6205388824027653 2.620538882402765 444.17735732435955 [535.89621821 562.10160703 942.07974498 968.2851338  548.99891262
 627.61507909 585.68645697 837.25818968 758.64202321 732.43663439]
'''


def mse_(B1, y = ks, x = zp, n = 10):
    return np.sum((B1*x - y)**2)/n

alpha = 1e-6
B1 = 0.1

for i in range (3000):
    B1 -= alpha * (2/n) * np.sum ((B1 * zp - ks) * zp)
    if i % 500 == 0:
        print ('Iteration = {i}, B1 = {B1}, mse = {mse}'.format(i = i, B1 = B1, mse = mse_(B1)))

'''
Iteration = 0, B1 = 0.25952808, mse = 493237.7212546963
Iteration = 500, B1 = 5.889815595583751, mse = 56516.858416040064
Iteration = 1000, B1 = 5.8898204201285544, mse = 56516.85841571941
Iteration = 1500, B1 = 5.889820420132673, mse = 56516.85841571943
Iteration = 2000, B1 = 5.889820420132673, mse = 56516.85841571943
Iteration = 2500, B1 = 5.889820420132673, mse = 56516.85841571943

print(mse_(5.8898204201))
56516.8584157194
'''

########################################################################

def mse_1(B1, B0, y = ks, x = zp, n = 10):
    return np.sum((B0 + B1*x - y)**2)/n

alpha = 1e-6
B0 = 0.1
B1 = 0.1

for i in range (3000):
    B1 -= alpha * (2/n) * np.sum ((B0 + B1 * zp - ks) * zp)
    B0 -= alpha * (2/n) * np.sum ((B0 + B1 * zp - ks) * zp)
    if i % 500 == 0:
        print ('Iteration = {i}, B1 = {B1}, B0 = {B0}, mse = {mse}'.format(i = i, B1 = B1, B0 = B0, mse = mse_1(B1, B0)))

'''
Iteration = 0, B1 = 0.2595078, B0 = 0.25511284968504, mse = 492892.14933292643
Iteration = 500, B1 = 5.847939119406923, B0 = 5.689565003262093, mse = 55242.958121947435
Iteration = 1000, B1 = 5.847943446276081, B0 = 5.68956921091216, mse = 55242.95718566068
Iteration = 1500, B1 = 5.847943446279413, B0 = 5.6895692109154, mse = 55242.95718565994
Iteration = 2000, B1 = 5.847943446279413, B0 = 5.6895692109154, mse = 55242.95718565994
Iteration = 2500, B1 = 5.847943446279413, B0 = 5.6895692109154, mse = 55242.95718565994

print(mse_1(5.84794344627, 5.68956921091))
55242.957185661144
'''
